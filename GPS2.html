<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wordle 3D Adventure - 政府信息公开系统</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-color: #f1efe8;
            --border-color: #111;
            --accent-color: #4a8c2d;
            --text-color: #111;
            --grid-correct: #4a8c2d;
            --grid-present: #c9b458;
            --grid-absent: #787c7e;
            --grid-default: #fff;
        }

        body {
            font-family: 'Courier New', 'SimSun', monospace;
            background-color: var(--bg-color);
            color: var(--text-color);
            min-height: 100vh;
            overflow-x: hidden;
            letter-spacing: -0.02em;
        }

        /* 几何装饰背景 */
        .geo-decoration {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 0;
            overflow: hidden;
        }

        .geo-line {
            position: absolute;
            background: var(--border-color);
            opacity: 0.08;
        }

        .geo-line.h1 { top: 15%; left: 0; width: 100%; height: 1px; }
        .geo-line.h2 { top: 45%; left: 0; width: 100%; height: 1px; }
        .geo-line.h3 { top: 75%; left: 0; width: 100%; height: 1px; }
        .geo-line.v1 { left: 20%; top: 0; width: 1px; height: 100%; }
        .geo-line.v2 { left: 50%; top: 0; width: 1px; height: 100%; }
        .geo-line.v3 { left: 80%; top: 0; width: 1px; height: 100%; }

        .geo-circle {
            position: absolute;
            border: 1px solid var(--border-color);
            border-radius: 50%;
            opacity: 0.06;
        }

        .geo-circle.c1 { width: 300px; height: 300px; top: -100px; right: -50px; }
        .geo-circle.c2 { width: 200px; height: 200px; bottom: 10%; left: 5%; }
        .geo-circle.c3 { width: 150px; height: 150px; top: 30%; right: 15%; }

        .geo-square {
            position: absolute;
            border: 1px solid var(--accent-color);
            opacity: 0.1;
            transform: rotate(45deg);
        }

        .geo-square.s1 { width: 60px; height: 60px; top: 20%; left: 10%; }
        .geo-square.s2 { width: 40px; height: 40px; bottom: 30%; right: 20%; }
        .geo-square.s3 { width: 80px; height: 80px; top: 60%; left: 70%; }

        /* 主容器 */
        .container {
            position: relative;
            z-index: 1;
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        /* 头部区域 */
        .header {
            border: 2px solid var(--border-color);
            background: var(--bg-color);
            margin-bottom: 20px;
            position: relative;
        }

        .header::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-color);
        }

        .header-content {
            padding: 20px 30px;
        }

        .system-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            color: var(--accent-color);
            margin-bottom: 8px;
            font-weight: bold;
        }

        .system-title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 10px;
            letter-spacing: -0.03em;
        }

        .system-meta {
            font-size: 12px;
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }

        .meta-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .meta-label {
            color: #666;
            font-size: 10px;
            text-transform: uppercase;
        }

        .meta-value {
            font-weight: bold;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 1px;
        }

        /* 状态栏 */
        .status-bar {
            border: 2px solid var(--border-color);
            border-top: none;
            background: var(--bg-color);
            padding: 12px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--accent-color);
            border: 1px solid var(--border-color);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        /* 主要内容区 */
        .main-content {
            border: 2px solid var(--border-color);
            background: var(--bg-color);
            position: relative;
            min-height: 500px;
        }

        .main-content::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-color);
        }

        .content-inner {
            padding: 30px;
        }

        .section-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 5px;
        }

        .section-subtitle {
            font-size: 11px;
            color: #666;
        }

        /* Wordle 游戏区域 */
        .wordle-section {
            border: 2px solid var(--border-color);
            margin-top: 20px;
            position: relative;
            background: #fff;
        }

        .wordle-section::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-color);
        }

        .wordle-header {
            background: var(--bg-color);
            border-bottom: 2px solid var(--border-color);
            padding: 15px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .wordle-title {
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .wordle-status {
            font-size: 10px;
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            background: var(--bg-color);
        }

        .wordle-container {
            padding: 30px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* 游戏网格 - 保持3d2的原始样式但适配新主题 */
        .game-grid {
            display: grid;
            grid-template-rows: repeat(6, 1fr);
            gap: 8px;
            margin-bottom: 20px;
        }

        .grid-row-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .grid-row {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .grid-cell {
            width: 60px;
            height: 60px;
            border: 2px solid var(--border-color);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 28px;
            font-weight: bold;
            text-transform: uppercase;
            background: var(--grid-default);
            transition: all 0.3s ease;
            font-family: 'Courier New', monospace;
        }

        .grid-cell.filled {
            border-color: var(--border-color);
            animation: pop 0.1s ease;
        }

        .grid-cell.correct {
            background: var(--grid-correct);
            color: white;
            border-color: var(--grid-correct);
        }

        .grid-cell.present {
            background: var(--grid-present);
            color: white;
            border-color: var(--grid-present);
        }

        .grid-cell.absent {
            background: var(--grid-absent);
            color: white;
            border-color: var(--grid-absent);
        }

        .grid-cell.disabled {
            background: #2d2d2d;
            border-color: #1a1a1a;
            color: #666;
            cursor: not-allowed;
        }

        @keyframes pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @keyframes flip {
            0% { transform: rotateX(0); }
            50% { transform: rotateX(90deg); }
            100% { transform: rotateX(0); }
        }

        .grid-cell.flip {
            animation: flip 0.5s ease;
        }

        /* 左侧圆点和右侧方格 - 保留3d2的特色 */
        .side-dot {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .side-square {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.2);
        }

        /* 虚拟键盘 */
        .keyboard {
            display: flex;
            flex-direction: column;
            gap: 8px;
            width: 100%;
            max-width: 500px;
        }

        .keyboard-row {
            display: flex;
            justify-content: center;
            gap: 6px;
        }

        .key {
            height: 50px;
            min-width: 40px;
            border: 2px solid var(--border-color);
            background: var(--bg-color);
            font-family: 'Courier New', monospace;
            font-size: 14px;
            font-weight: bold;
            text-transform: uppercase;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s ease;
            padding: 0 10px;
        }

        .key:hover {
            background: var(--accent-color);
            color: white;
            transform: translateY(-2px);
        }

        .key:active {
            transform: translateY(0);
        }

        .key.wide {
            min-width: 65px;
            font-size: 11px;
        }

        .key.correct {
            background: var(--grid-correct);
            color: white;
            border-color: var(--grid-correct);
        }

        .key.present {
            background: var(--grid-present);
            color: white;
            border-color: var(--grid-present);
        }

        .key.absent {
            background: var(--grid-absent);
            color: white;
            border-color: var(--grid-absent);
        }

        .key.disabled {
            background: #3a3a3c !important;
            color: #666;
            cursor: not-allowed;
            opacity: 0.5;
        }

        /* 消息提示 */
        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-color);
            border: 2px solid var(--border-color);
            padding: 20px 40px;
            font-size: 14px;
            font-weight: bold;
            z-index: 1000;
            display: none;
            box-shadow: 8px 8px 0 var(--border-color);
        }

        .message.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        /* 底部信息 */
        .footer {
            margin-top: 20px;
            border: 2px solid var(--border-color);
            background: var(--bg-color);
            position: relative;
            padding: 20px 30px;
            font-size: 10px;
            color: #666;
        }

        .footer::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            width: 4px;
            height: 100%;
            background: var(--accent-color);
        }

        .footer-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .footer-section h4 {
            font-size: 10px;
            text-transform: uppercase;
            margin-bottom: 8px;
            color: var(--text-color);
            letter-spacing: 0.1em;
        }

        .footer-section p {
            line-height: 1.6;
        }

        /* 3D场景容器 - 美化后的风格与wordle主题一致 */
        #scene-container {
            opacity: 0;
            transition: opacity 1s ease;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 50;
            display: none;
            /* 背景使用wordle风格的柔和米色，并叠加几何装饰 */
            background: var(--bg-color);
        }

        #scene-container.active { 
            opacity: 1; 
            display: block; 
        }

        /* 在3D画布上层叠加几何装饰，与wordle风格呼应 */
        .scene-geo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 60;
            overflow: hidden;
        }
        .scene-geo-overlay .geo-line {
            background: var(--border-color);
            opacity: 0.1;
        }
        .scene-geo-overlay .geo-circle {
            border-color: var(--border-color);
            opacity: 0.08;
        }
        .scene-geo-overlay .geo-square {
            border-color: var(--accent-color);
            opacity: 0.15;
        }

        .overlay-ui {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 100;
            text-align: center;
            background: var(--bg-color); /* 改为与主题一致的米色背景 */
            padding: 20px 25px;
            border-radius: 0; /* 改为直角，加边框模拟wordle风格 */
            border: 2px solid var(--border-color);
            box-shadow: 8px 8px 0 rgba(0,0,0,0.2);
            max-width: 380px;
            max-height: 280px;
            overflow-y: auto;
            color: var(--text-color);
            font-family: 'Courier New', monospace;
        }

        .retry-btn {
            background: var(--bg-color);
            border: 2px solid var(--border-color);
            padding: 10px 25px;
            border-radius: 0;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--text-color);
            font-size: 13px;
            font-family: 'Courier New', monospace;
            box-shadow: 4px 4px 0 var(--border-color);
        }

        .retry-btn:hover { 
            background: var(--accent-color); 
            color: white;
            border-color: var(--accent-color);
            box-shadow: 2px 2px 0 var(--border-color);
            transform: translate(2px, 2px);
        }

        .legend {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 8px;
            font-size: 11px;
            flex-wrap: wrap;
        }

        .legend-item { 
            display: flex; 
            align-items: center; 
            gap: 4px; 
        }
        
        .legend-color { 
            width: 14px; 
            height: 14px; 
            border-radius: 3px; 
        }

        .path-indicator {
            margin-top: 10px;
            padding: 10px;
            background: rgba(0,0,0,0.03);
            border: 1px dashed var(--border-color);
            border-radius: 0;
            font-size: 11px;
            line-height: 1.4;
            text-align: left;
            max-height: 100px;
            overflow-y: auto;
            color: var(--text-color);
        }

        .hint-text {
            font-size: 11px;
            color: #666;
            margin-top: 8px;
            text-align: center;
            font-family: 'Courier New', monospace;
        }

        /* 响应式 */
        @media (max-width: 600px) {
            .grid-cell {
                width: 50px;
                height: 50px;
                font-size: 24px;
            }
            
            .key {
                height: 45px;
                min-width: 32px;
                font-size: 12px;
            }
            
            .key.wide {
                min-width: 50px;
            }

            .side-dot {
                width: 16px;
                height: 16px;
            }

            .side-square {
                width: 20px;
                height: 20px;
            }
        }

        /* 装饰性数据流 */
        .data-stream {
            position: absolute;
            right: 20px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            color: var(--accent-color);
            opacity: 0.3;
            font-family: monospace;
            line-height: 1.8;
            pointer-events: none;
        }
    </style>
<base target="_blank">
</head>
<body>
    <!-- 几何装饰背景 -->
    <div class="geo-decoration">
        <div class="geo-line h1"></div>
        <div class="geo-line h2"></div>
        <div class="geo-line h3"></div>
        <div class="geo-line v1"></div>
        <div class="geo-line v2"></div>
        <div class="geo-line v3"></div>
        <div class="geo-circle c1"></div>
        <div class="geo-circle c2"></div>
        <div class="geo-circle c3"></div>
        <div class="geo-square s1"></div>
        <div class="geo-square s2"></div>
        <div class="geo-square s3"></div>
    </div>

    <div class="container">
        <!-- 头部 -->
        <div class="header">
            <div class="header-content">
                <div class="system-label">/// 政府信息公开系统 ///</div>
                <h1 class="system-title">GPS轨迹大数据查询平台</h1>
                <div class="system-meta">
                    <div class="meta-item">
                        <span class="meta-label">查询区域</span>
                        <span class="meta-value highlight">氹环区·光明街道</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">关联地标</span>
                        <span class="meta-value">环湾金融城</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">申请编号</span>
                        <span class="meta-value">3D-GPS-2025-1111</span>
                    </div>
                    <div class="meta-item">
                        <span class="meta-label">目标单词</span>
                        <span class="meta-value">待解密</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- 状态栏 -->
        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot"></div>
                <span>系统在线 | 注意：第2行禁用第1、3行出现的灰色字母 | 第3行预置 JACKY</span>
            </div>
            <span>最后更新: 2025-02-25 09:00:00</span>
        </div>

        <!-- 主要内容 -->
        <div class="main-content" id="game-container">
            <div class="content-inner">
                <div class="section-header">
                    <div class="section-title">轨迹查询申请详情</div>
                    <div class="section-subtitle">根据《南山市交通运输局公告》(2024-01-15) 依法申请公开 | 查询范围: 林静怡、周变等出现在光明街道的人员的GPS轨迹 | 六次内未猜中则游戏失败自动重置</div>
                </div>

                <!-- Wordle 游戏区域 -->
                <div class="wordle-section">
                    <div class="wordle-header">
                        <div class="wordle-title">/// 访问验证协议 /// 请输入解密密钥 </div>
                        <div class="wordle-status" id="row-hint">当前在第1行输入</div>
                    </div>
                    <div class="wordle-container">
                        <div class="game-grid" id="wordle-grid">
                            <!-- 网格将通过JS生成 -->
                        </div>
                        
                        <p class="hint-text" id="row-hint-text">当前在第1行输入</p>

                        <div class="keyboard" id="keyboard">
                            <!-- 键盘将通过JS生成 -->
                        </div>

                        <p class="hint-text">输入单词后按 ENTER 提交 | 第4行第3格预置F | 第5行第1格U第5格X预置</p>
                    </div>
                    <div class="data-stream">
                        WORDLE规则：<br>
                        绿色：字母正确且位置正确<br>
                        黄色：字母正确但位置错误<br>
                        灰色：字母不存在于目标单词中
                        注意：<br>
                        输入单词需要在wordle database中出现过，即必须是合理单词<br>
                        相关单词库请自行进行外部搜索哦！<br>
                    </div>
                </div>
            </div>
        </div>

        <!-- 底部 -->
        <div class="footer">
            <div class="footer-grid">
                <div class="footer-section">
                    <h4>系统说明</h4>
                    <p>本系统依据《政府信息公开条例》及南山市交通运输局2024年1月15日公告设立，提供全市交通GPS轨迹大数据查询服务。查询范围涵盖公交、客运车辆、网约车、出租车等多种交通业态。所有查询行为全程记录，严禁用于非法用途。</p>
                </div>
                <div class="footer-section">
                    <h4>安全提示</h4>
                    <p>当前查询涉及氹环区光明街道周边GPS数据。该数据与SBTP智慧商旅通系统、国际酒店（会场店）能耗监测数据存在交叉验证关系。</p>
                </div>
            </div>
        </div>
    </div>

    <!-- 3D场景容器 - 美化后 -->
    <div id="scene-container">
        <!-- 叠加与wordle一致的几何装饰层 -->
        <div class="scene-geo-overlay">
            <div class="geo-line h1"></div>
            <div class="geo-line h2"></div>
            <div class="geo-line h3"></div>
            <div class="geo-line v1"></div>
            <div class="geo-line v2"></div>
            <div class="geo-line v3"></div>
            <div class="geo-circle c1"></div>
            <div class="geo-circle c2"></div>
            <div class="geo-circle c3"></div>
            <div class="geo-square s1"></div>
            <div class="geo-square s2"></div>
            <div class="geo-square s3"></div>
        </div>
        <div class="overlay-ui">
            <h2 class="text-xl font-bold mb-2" style="font-size: 16px; color: var(--text-color);">路径验证</h2>
            <div class="legend">
                <div class="legend-item">
                    <span>轨迹与人物进行匹配...</span>
                </div>
            </div>
            <div class="path-indicator" id="scene-desc">
                <div style="color: var(--accent-color);">开始匹配...</div>
            </div>
            <button class="retry-btn" onclick="resetGame()">Retry</button>
        </div>
    </div>

    <!-- 消息提示 -->
    <div class="message" id="message"></div>

    <script>
        // ==================== 以下是3d2.html的原始逻辑，完全保留 ====================
        
        const targetWord = "SHINE";
        const PRESET_ROW = 2; // 第三行（0-indexed）
        const PRESET_WORD = "JACKY";
        const DISABLED_LETTERS_ROW1 = ['J', 'A', 'C', 'K', 'Y', 'O']; // 第2行禁用的字母
        
        // 新增预置格子配置
        const PRESET_CELLS = [
            { row: 3, col: 2, letter: 'F' },  // 第四行第3格 (0-indexed: row 3, col 2)
            { row: 4, col: 0, letter: 'U' },  // 第五行第1格 (0-indexed: row 4, col 0)
            { row: 4, col: 4, letter: 'X' }   // 第五行第5格 (0-indexed: row 4, col 4)
        ];
        
        // 5字母英文单词库（用于验证输入是否为有效单词）
        const VALID_WORDS = [
            // 常见5字母单词 - 按字母顺序排列便于查找
            "ABOUT", "ABOVE", "ABUSE", "ACTOR", "ACUTE", "ADMIT", "ADOPT", "ADULT", "AFTER", "AGAIN",
            "AGENT", "AGREE", "AHEAD", "ALARM", "ALBUM", "ALERT", "ALIKE", "ALIVE", "ALLOW", "ALONE",
            "ALONG", "ALTER", "ANGEL", "ANGER", "ANGLE", "ANGRY", "APART", "APPLE", "APPLY", "ARENA",
            "ARGUE", "ARISE", "ARRAY", "ASIDE", "ASSET", "AVOID", "AWARD", "AWARE", "BADLY", "BAKER",
            "BASES", "BASIC", "BEACH", "BEGAN", "BEING", "BELOW", "BENCH", "BILLY", "BIRTH", "BLACK",
            "BLAME", "BLIND", "BLOCK", "BLOOD", "BOARD", "BOOST", "BOOTH", "BOUND", "BRAIN", "BRAND",
            "BRAVE", "BREAD", "BREAK", "BREED", "BRIEF", "BRING", "BROAD", "BROKE", "BROWN", "BUILD",
            "BUILT", "BUYER", "CABLE", "CALIF", "CARRY", "CATCH", "CAUSE", "CHAIN", "CHAIR", "CHAOS",
            "CHARM", "CHART", "CHASE", "CHEAP", "CHECK", "CHEST", "CHIEF", "CHILD", "CHINA", "CHOSE",
            "CIVIC", "CIVIL", "CLAIM", "CLASS", "CLEAN", "CLEAR", "CLICK", "CLIMB", "CLOCK", "CLOSE",
            "CLOUD", "COACH", "COAST", "COULD", "COUNT", "COURT", "COVER", "CRAFT", "CRASH", "CRAZY",
            "CREAM", "CRIME", "CROSS", "CROWD", "CROWN", "CRUDE", "CURVE", "CYCLE", "DAILY", "DANCE",
            "DATED", "DEALT", "DEATH", "DEBUT", "DELAY", "DELTA", "DENSE", "DEPOT", "DEPTH", "DERBY",
            "DIGIT", "DIRTY", "DOZEN", "DRAFT", "DRAMA", "DRANK", "DRAWN", "DREAM", "DRESS", "DRILL",
            "DRINK", "DRIVE", "DROVE", "DYING", "EAGER", "EARLY", "EARTH", "EIGHT", "EITHER", "ELECT",
            "ELITE", "EMPTY", "ENEMY", "ENJOY", "ENTER", "ENTRY", "EQUAL", "ERROR", "EVENT", "EVERY",
            "EXACT", "EXIST", "EXTRA", "FAITH", "FALSE", "FAULT", "FENCE", "FIBER", "FIELD", "FIERY",
            "FIFTH", "FIFTY", "FIGHT", "FINAL", "FIRST", "FIXED", "FLASH", "FLEET", "FLOOR", "FLUID",
            "FOCUS", "FORCE", "FORTH", "FORTY", "FORUM", "FOUND", "FRAME", "FRANK", "FRAUD", "FRESH",
            "FRONT", "FRUIT", "FULLY", "FUNNY", "GIANT", "GIVEN", "GLASS", "GLOBE", "GOING", "GRACE",
            "GRADE", "GRAND", "GRANT", "GRASS", "GRAVE", "GREAT", "GREEN", "GROSS", "GROUP", "GROWN",
            "GUARD", "GUESS", "GUEST", "GUIDE", "GUILT", "HAPPY", "HARRY", "HEART", "HEAVY", "HENCE",
            "HENRY", "HORSE", "HOTEL", "HOUSE", "HUMAN", "IDEAL", "IMAGE", "IMPLY", "INDEX", "INNER",
            "INPUT", "ISSUE", "JAPAN", "JIMMY", "JOINT", "JONES", "JUDGE", "KNOWN", "LABEL", "LARGE",
            "LASER", "LATER", "LAUGH", "LAYER", "LEARN", "LEASE", "LEAST", "LEAVE", "LEGAL", "LEMON",
            "LEVEL", "LEWIS", "LIGHT", "LIMIT", "LINKS", "LIVES", "LOCAL", "LOGIC", "LOOSE", "LOWER",
            "LUCKY", "LUNCH", "LYING", "MAGIC", "MAJOR", "MAKER", "MARCH", "MARIA", "MATCH", "MAYBE",
            "MAYOR", "MEANT", "MEDIA", "METAL", "MIGHT", "MINOR", "MINUS", "MIXED", "MODEL", "MONEY",
            "MONTH", "MORAL", "MOTOR", "MOUNT", "MOUSE", "MOUTH", "MOVED", "MOVIE", "MUSIC", "NEEDS",
            "NEVER", "NEWLY", "NIGHT", "NOISE", "NORTH", "NOTED", "NOVEL", "NURSE", "OCCUR", "OCEAN",
            "OFFER", "OFTEN", "ORDER", "OTHER", "OUGHT", "OUTER", "OWNED", "OWNER", "PAINT", "PANEL",
            "PAPER", "PARIS", "PARTY", "PEACE", "PENNY", "PETER", "PHASE", "PHONE", "PHOTO", "PIANO",
            "PIECE", "PILOT", "PITCH", "PLACE", "PLAIN", "PLANE", "PLANT", "PLATE", "PLAZA", "POINT",
            "POUND", "POWER", "PRESS", "PRICE", "PRIDE", "PRIME", "PRINT", "PRIOR", "PRIZE", "PROOF",
            "PROUD", "PROVE", "QUEEN", "QUICK", "QUIET", "QUITE", "RADIO", "RAISE", "RANGE", "RAPID",
            "RATIO", "REACH", "READY", "REALM", "REFER", "RELAX", "REPLY", "RIDER", "RIDGE", "RIFLE",
            "RIGHT", "RIGID", "RIVER", "ROBIN", "ROCKY", "ROGER", "ROMAN", "ROUGH", "ROUND", "ROUTE",
            "ROYAL", "RURAL", "SCALE", "SCENE", "SCOPE", "SCORE", "SCREW", "SENSE", "SERVE", "SEVEN",
            "SHALL", "SHAPE", "SHARE", "SHARP", "SHEET", "SHELF", "SHELL", "SHIFT", "SHINE", "SHIRT",
            "SHOCK", "SHOOT", "SHORE", "SHORT", "SHOWN", "SIGHT", "SILLY", "SINCE", "SIXTH", "SIXTY",
            "SIZED", "SKILL", "SLASH", "SLEEP", "SLIDE", "SLING", "SMALL", "SMART", "SMILE", "SMITH",
            "SMOKE", "SNAKE", "SOLID", "SOLVE", "SORRY", "SOUND", "SOUTH", "SPACE", "SPARE", "SPEAK",
            "SPEED", "SPEND", "SPENT", "SPLIT", "SPOKE", "SPORT", "SQUAD", "STAFF", "STAGE", "STAKE",
            "STAND", "START", "STATE", "STEAM", "STEEL", "STEEP", "STEER", "STICK", "STILL", "STOCK",
            "STONE", "STOOD", "STORE", "STORM", "STORY", "STRIP", "STUCK", "STUDY", "STUFF", "STYLE",
            "SUGAR", "SUITE", "SUNNY", "SUPER", "SURGE", "SWEET", "SWIFT", "SWING", "SWORD", "TABLE",
            "TAKEN", "TASTE", "TAXES", "TEACH", "TEAMS", "TEETH", "TEMPO", "TERRY", "TEXAS", "THANK",
            "THEFT", "THEIR", "THEME", "THERE", "THESE", "THICK", "THING", "THINK", "THIRD", "THOSE",
            "THREE", "THREW", "THROW", "THUMB", "TIGHT", "TIMER", "TITLE", "TODAY", "TOMMY", "TOPIC",
            "TOTAL", "TOUCH", "TOUGH", "TOWER", "TRACK", "TRADE", "TRAIL", "TRAIN", "TRASH", "TREAT",
            "TREND", "TRIAL", "TRIBE", "TRICK", "TRIED", "TRIES", "TROOP", "TRUCK", "TRULY", "TRUMP",
            "TRUST", "TRUTH", "TWICE", "TWINS", "UNCLE", "UNDER", "UNDUE", "UNION", "UNITY", "UNTIL",
            "UPPER", "UPSET", "URBAN", "USAGE", "USUAL", "VALID", "VALUE", "VIDEO", "VIRUS", "VISIT",
            "VOICE", "WASTE", "WATCH", "WATER", "WHEEL", "WHERE", "WHICH", "WHILE", "WHITE", "WHOLE",
            "WHOSE", "WOMAN", "WOMEN", "WORLD", "WORRY", "WORSE", "WORST", "WORTH", "WOULD", "WOUND",
            "WRITE", "WRONG", "WROTE", "YIELD", "YOUNG", "YOURS", "YOUTH", "ZEBRA", "ZONES","SPICE","JACKY",
            "SHADE","EPICS","PINES","MISES","ASHED","RECAN","ONSET","CORNY","SLOTH","TONES","HARES","UNSEX","NIFES","UNHIP",
            "CRAMP","SHADE","SHONE",

            
            // 游戏常用词
            "ADORE", "BEAUT", "CANDY", "DREAM", "EAGLE", "FLAME", "GRAPE", "HEART", "IMAGE", "JOKER",
            "KOALA", "LEMON", "MANGO", "NIGHT", "OCEAN", "PEACH", "QUEEN", "RIDER", "SNAKE", "TIGER",
            "UNCLE", "VENUS", "WHALE", "XENON", "YACHT", "ZEBRA",
            
            // 更多常用词
            "ALPHA", "BRAVO", "DELTA", "HOTEL", "INDIA", "OSCAR", "ROMEO",  "TANGO"
        ];

        // 将词库转换为Set以提高查找效率
        const VALID_WORDS_SET = new Set(VALID_WORDS);
        
        let currentRow = 0, currentCol = 0, grid = [], gameOver = false, allGuesses = [];

        function initGrid() {
            const gridEl = document.getElementById('wordle-grid');
            gridEl.innerHTML = '';
            grid = [];
            allGuesses = [];

            // 预置第三行的答案（JACKY vs SPICE的对比结果）
            const presetResult = checkWordAgainstTarget(PRESET_WORD, targetWord);

            for (let i = 0; i < 6; i++) {
                const row = [];
                const wrapper = document.createElement('div');
                wrapper.className = 'grid-row-wrapper';

                // 左侧圆点（第1、2、4行）
                if (i === 0 || i === 1 || i === 3) {
                    const dot = document.createElement('div');
                    dot.className = 'side-dot';
                    if (i === 0) dot.style.background = '#22c55e'; // 绿色
                    else if (i === 1) dot.style.background = '#6b7280'; // 灰色
                    else if (i === 3) dot.style.background = '#eab308'; // 黄色
                    wrapper.appendChild(dot);
                } else {
                    // 占位保持对齐
                    const spacer = document.createElement('div');
                    spacer.style.width = '32px';
                    wrapper.appendChild(spacer);
                }

                const rowEl = document.createElement('div');
                rowEl.className = 'grid-row';
                rowEl.dataset.rowIndex = i;

                for (let j = 0; j < 5; j++) {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;

                    // 检查是否是预置格子（第三行JACKY或新增的预置格子）
                    const presetCell = PRESET_CELLS.find(p => p.row === i && p.col === j);
                    
                    if (i === PRESET_ROW) {
                        // 第三行预置JACKY
                        cell.textContent = PRESET_WORD[j];
                        cell.classList.add('filled', 'disabled');
                        // 添加颜色标记（根据与SPICE的对比）
                        if (presetResult[j] === 'correct') cell.classList.add('correct');
                        else if (presetResult[j] === 'present') cell.classList.add('present');
                        else cell.classList.add('absent');
                    } else if (presetCell) {
                        // 其他预置格子（第四行F，第五行U和X）- 同样使用灰色禁用样式
                        cell.textContent = presetCell.letter;
                        cell.classList.add('filled', 'disabled');
                        // 计算该字母与目标词SPICE的匹配结果
                        const letterResult = checkLetterAgainstTarget(presetCell.letter, j, targetWord);
                        if (letterResult === 'correct') cell.classList.add('correct');
                        else if (letterResult === 'present') cell.classList.add('present');
                        else cell.classList.add('absent');
                    }

                    rowEl.appendChild(cell);
                    row.push(cell);
                }
                wrapper.appendChild(rowEl);

                // 右侧方格（第1、2、4行）
                if (i === 0 || i === 1 || i === 3) {
                    const square = document.createElement('div');
                    square.className = 'side-square';
                    if (i === 0) square.style.background = '#22c55e'; // 绿色
                    else if (i === 1) square.style.background = '#6b7280'; // 灰色
                    else if (i === 3) square.style.background = '#eab308'; // 黄色
                    wrapper.appendChild(square);
                } else {
                    // 占位保持对齐
                    const spacer = document.createElement('div');
                    spacer.style.width = '36px';
                    wrapper.appendChild(spacer);
                }

                gridEl.appendChild(wrapper);
                grid.push(row);
            }

            // 预先将第三行加入allGuesses
            allGuesses.push({ 
                row: PRESET_ROW, 
                word: PRESET_WORD, 
                result: presetResult 
            });
        }

        // 检查单词与目标词的匹配结果（用于预置行）
        function checkWordAgainstTarget(guess, target) {
            const result = [];
            const targetLetters = target.split('');
            const guessLetters = guess.split('');

            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] === targetLetters[i]) {
                    result[i] = 'correct';
                    targetLetters[i] = null;
                    guessLetters[i] = null;
                }
            }

            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] !== null) {
                    const index = targetLetters.indexOf(guessLetters[i]);
                    if (index !== -1) {
                        result[i] = 'present';
                        targetLetters[index] = null;
                    } else {
                        result[i] = 'absent';
                    }
                }
            }
            return result;
        }

        // 检查单个字母与目标词的位置匹配结果
        function checkLetterAgainstTarget(letter, position, target) {
            if (letter === target[position]) return 'correct';
            if (target.includes(letter)) return 'present';
            return 'absent';
        }

        function initKeyboard() {
            const rows = [
                'QWERTYUIOP'.split(''),
                'ASDFGHJKL'.split(''),
                ['ENTER', ...'ZXCVBNM'.split(''), 'BACKSPACE']
            ];

            rows.forEach((row, i) => {
                const container = document.createElement('div');
                container.className = 'keyboard-row';
                row.forEach(key => {
                    const keyEl = document.createElement('button');
                    keyEl.className = `key ${key.length > 1 ? 'wide' : ''}`;
                    keyEl.textContent = key === 'BACKSPACE' ? '⌫' : key;
                    keyEl.dataset.key = key;
                    keyEl.onclick = () => handleKey(key);
                    container.appendChild(keyEl);
                });
                document.getElementById('keyboard').appendChild(container);
            });
        }

        function updateKeyboardForRow(row) {
            // 重置所有按键
            document.querySelectorAll('.key').forEach(key => {
                key.classList.remove('disabled');
            });

            // 如果是第2行（0-indexed的第1行），禁用JACKYO
            if (row === 1) {
                DISABLED_LETTERS_ROW1.forEach(letter => {
                    const keyEl = document.querySelector(`[data-key="${letter}"]`);
                    if (keyEl) keyEl.classList.add('disabled');
                });
            }
        }

        // 检查当前格子是否是预置格子（需要跳过）
        function isPresetCell(row, col) {
            if (row === PRESET_ROW) return true; // 第三行整行预置
            return PRESET_CELLS.some(p => p.row === row && p.col === col);
        }

        // 获取下一个可输入的列
        function getNextInputCol(row, startCol) {
            for (let c = startCol; c < 5; c++) {
                if (!isPresetCell(row, c)) return c;
            }
            return -1; // 没有可输入的位置
        }

        // 获取上一个可输入的列（用于退格）
        function getPrevInputCol(row, startCol) {
            for (let c = startCol; c >= 0; c--) {
                if (!isPresetCell(row, c)) return c;
            }
            return -1; // 没有可输入的位置
        }

        // 验证单词是否在词库中
        function isValidWord(word) {
            return VALID_WORDS_SET.has(word);
        }

        function handleKey(key) {
            if (gameOver) return;

            // 检查是否是禁用的字母（在第2行）
            if (currentRow === 1 && key.length === 1 && DISABLED_LETTERS_ROW1.includes(key)) {
                showMessage(`第2行不能使用字母 ${key}！`);
                return;
            }

            if (key === 'ENTER') submitGuess();
            else if (key === 'BACK' || key === 'BACKSPACE') {
                // 找到当前实际有内容的位置（从currentCol-1开始往回找）
                let targetCol = -1;
                for (let c = currentCol - 1; c >= 0; c--) {
                    if (!isPresetCell(currentRow, c) && grid[currentRow][c].textContent !== '') {
                        targetCol = c;
                        break;
                    }
                }

                // 如果找到了有内容的格子，清除它
                if (targetCol >= 0) {
                    grid[currentRow][targetCol].textContent = '';
                    grid[currentRow][targetCol].classList.remove('filled');
                    currentCol = targetCol;
                } else {
                    // 没找到有内容的，就找上一个可输入的空位置
                    const prevCol = getPrevInputCol(currentRow, currentCol - 1);
                    if (prevCol >= 0) {
                        currentCol = prevCol;
                    }
                }
            } else if (key.length === 1) {
                // 找到下一个可输入的位置
                const nextCol = getNextInputCol(currentRow, currentCol);
                if (nextCol >= 0) {
                    currentCol = nextCol;
                    grid[currentRow][currentCol].textContent = key;
                    grid[currentRow][currentCol].classList.add('filled');
                    // 移动到下一个可输入位置
                    const nextNextCol = getNextInputCol(currentRow, currentCol + 1);
                    currentCol = nextNextCol >= 0 ? nextNextCol : currentCol + 1;
                }
            }
        }

        function submitGuess() {
            // 检查是否填满了所有非预置格子
            const filledCount = grid[currentRow].filter((cell, idx) => 
                !isPresetCell(currentRow, idx) && cell.textContent !== ''
            ).length;
            
            const presetCount = PRESET_CELLS.filter(p => p.row === currentRow).length;
            const requiredCount = 5 - presetCount;
            
            if (filledCount < requiredCount) { 
                showMessage('单词太短！'); 
                return; 
            }

            // 构建完整单词（包含预置字母）
            const guess = grid[currentRow].map((cell, idx) => {
                if (isPresetCell(currentRow, idx)) {
                    // 获取预置字母
                    if (currentRow === PRESET_ROW) return PRESET_WORD[idx];
                    const preset = PRESET_CELLS.find(p => p.row === currentRow && p.col === idx);
                    return preset ? preset.letter : '';
                }
                return cell.textContent;
            }).join('');

            // 验证单词是否在词库中
            if (!isValidWord(guess)) {
                showMessage(`"${guess}" 不是有效单词！`);
                return;
            }

            const result = checkWord(guess);

            allGuesses.push({ row: currentRow, word: guess, result: result });

            // 动画显示结果（只动画非预置格子）
            grid[currentRow].forEach((cell, i) => {
                if (isPresetCell(currentRow, i)) return; // 跳过预置格子
                
                setTimeout(() => {
                    cell.classList.add('flip');
                    setTimeout(() => {
                        cell.classList.remove('flip');
                        cell.classList.add(result[i]);
                    }, 250);
                }, i * 80);
            });

            updateKeyboard(guess, result);

            if (guess === targetWord) {
                // 猜对了，进入3D场景
                gameOver = true;
                setTimeout(() => start3DScene(), 1200);
            } else if (currentRow === 5) {
                // 第六行（最后一行）也没猜对，游戏失败，直接重置
                gameOver = true;
                setTimeout(() => {
                    showMessage('游戏失败！即将重置...');
                    setTimeout(() => {
                        location.reload(); // 直接重置页面，不显示答案
                    }, 1500);
                }, 1200);
            } else {
                // 跳到下一行，跳过预置的第三行
                currentRow++;
                if (currentRow === PRESET_ROW) currentRow++;
                currentCol = 0;
                updateRowHint();
                updateKeyboardForRow(currentRow);
            }
        }

        function checkWord(guess) {
            const result = [];
            const targetLetters = targetWord.split('');
            const guessLetters = guess.split('');

            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] === targetLetters[i]) {
                    result[i] = 'correct';
                    targetLetters[i] = null;
                    guessLetters[i] = null;
                }
            }

            for (let i = 0; i < 5; i++) {
                if (guessLetters[i] !== null) {
                    const index = targetLetters.indexOf(guessLetters[i]);
                    if (index !== -1) {
                        result[i] = 'present';
                        targetLetters[index] = null;
                    } else {
                        result[i] = 'absent';
                    }
                }
            }
            return result;
        }

        function updateKeyboard(guess, result) {
            guess.split('').forEach((char, i) => {
                const keyEl = document.querySelector(`[data-key="${char}"]`);
                if (keyEl) {
                    const currentBg = keyEl.style.background;
                    const newBg = result[i] === 'correct' ? '#538d4e' : result[i] === 'present' ? '#b59f3b' : '#3a3a3c';
                    if (!currentBg || (currentBg !== 'rgb(83, 141, 78)' && result[i] === 'correct') ||
                        (currentBg === 'rgb(58, 58, 60)' && result[i] !== 'absent')) {
                        keyEl.style.background = newBg;
                    }
                }
            });
        }

        function updateRowHint() {
            const hint = document.getElementById('row-hint');
            const hintText = document.getElementById('row-hint-text');
            let text = '';
            
            if (currentRow === 1) {
                text = '当前在第2行输入 (禁用: J,A,C,K,Y,O)';
            } else if (currentRow === 3) {
                text = '当前在第4行输入 (第3格已预置F)';
            } else if (currentRow === 4) {
                text = '当前在第5行输入 (第1格U第5格X已预置)';
            } else {
                text = `当前在第${currentRow + 1}行输入`;
            }
            
            hint.textContent = text;
            hintText.textContent = text;
        }

        function showMessage(text) {
            const msg = document.getElementById('message');
            msg.innerHTML = text;
            msg.classList.add('show');
            setTimeout(() => msg.classList.remove('show'), 2000);
        }

        // Three.js
        let scene, camera, renderer, characters = [], allBlocks = [], houses = {};

        // 相机动画相关变量
        let cameraAnimationStartTime = null;
        let cameraAnimationDuration = 3000; // 3秒动画
        let cameraAnimationActive = false;

        // 定义相机运动的起点和终点
        const cameraStartPos = new THREE.Vector3(0, 40, 0);  // 纯正面视角（起点）
        const cameraStartLookAt = new THREE.Vector3(0, 0, 0); // 看向中心偏上

        const cameraEndPos = new THREE.Vector3(0, 30, 30);     // 正面平视视角（终点）
        const cameraEndLookAt = new THREE.Vector3(0, 5, 0);   // 看向中心偏上

        // 新增：标志小人动画是否已开始
        let charactersAnimationStarted = false;

        function startCameraAnimation() {
            cameraAnimationActive = true;
            cameraAnimationStartTime = performance.now();
            
            // 设置初始相机位置
            camera.position.copy(cameraStartPos);
            camera.lookAt(cameraStartLookAt);
        }

        function updateCameraAnimation() {
            if (!cameraAnimationActive) return;
            
            const currentTime = performance.now();
            const elapsed = currentTime - cameraAnimationStartTime;
            let progress = Math.min(elapsed / cameraAnimationDuration, 1);
            
            // 使用缓动函数让动画更平滑
            progress = easeInOutCubic(progress);
            
            // 插值相机位置
            camera.position.lerpVectors(cameraStartPos, cameraEndPos, progress);
            
            // 插值观察点
            const currentLookAt = new THREE.Vector3().lerpVectors(
                cameraStartLookAt, 
                cameraEndLookAt, 
                progress
            );
            camera.lookAt(currentLookAt);
            
            // 动画结束
            if (progress >= 1) {
                cameraAnimationActive = false;
                
                // 相机动画完成后，启动小人动画
                if (!charactersAnimationStarted) {
                    charactersAnimationStarted = true;
                    
                    // 先开始持续跳动动画
                    startContinuousJumping();
                    
                    // 延迟一点开始寻路动画，让跳动先展示一下，增加视觉效果
                    setTimeout(() => {
                        animateAllCharacters();
                    }, 500);
                }
            }
        }

        // 缓动函数 - 平滑开始和结束
        function easeInOutCubic(x) {
            return x < 0.5 ? 4 * x * x * x : 1 - Math.pow(-2 * x + 2, 3) / 2;
        }

        function start3DScene() {
            document.getElementById('game-container').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('scene-container').classList.add('active');
                init3D();
            }, 500);
        }

        function init3D() {
            const container = document.getElementById('scene-container');
            scene = new THREE.Scene();
            // 背景色改为与wordle一致的柔和米色
            scene.background = new THREE.Color(0xf1efe8); 

            const aspect = window.innerWidth / window.innerHeight;
            const d = 9;
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            
            // 设置初始相机位置为纯正面视角
            camera.position.set(0, 40, 0);
            camera.lookAt(0, 5, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            // 清空之前可能存在的canvas
            while (container.firstChild) {
                if (container.firstChild.nodeName === 'CANVAS') container.removeChild(container.firstChild);
                else break;
            }
            container.appendChild(renderer.domElement);

            // 灯光调整，更柔和明亮，符合wordle风格
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.9);
            dirLight.position.set(15, 25, 15);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);

            // 添加辅助背光
            const backLight = new THREE.DirectionalLight(0xffeedd, 0.4);
            backLight.position.set(-10, 5, -10);
            scene.add(backLight);

            // Create board
            allBlocks = [];
            const startX = -8;
            const startZ = -6;
            const spacingX = 2.2;
            const spacingZ = 2.2;

            // 创建所有6行的格子 - 有输入的用3D，没输入的用2D图案
            for (let row = 0; row < 6; row++) {
                const guessData = allGuesses.find(g => g.row === row);
                
                if (guessData) {
                    // 有输入的行 - 创建3D格子（根据正确答案绘制颜色）
                    const word = guessData.word;
                    const result = guessData.result;

                    for (let col = 0; col < 5; col++) {
                        const colorHex = result[col] === 'correct' ? 0x22c55e : 
                                        result[col] === 'present' ? 0xeab308 : 0x6b7280;
                        createBlock(col, row, word[col], startX + col * spacingX, startZ + row * spacingZ, colorHex, result[col]);
                    }
                } else {
                    // 没有输入的行 - 创建2D方形图案
                    for (let col = 0; col < 5; col++) {
                        createEmptyPattern(col, row, startX + col * spacingX, startZ + row * spacingZ);
                    }
                }
            }

            // Create characters and houses at specific rows
            characters = [];
            houses = {};

            // Green character - Row 1 (index 0)
            const greenChar = createCharacter(0x22c55e, 'green');
            greenChar.userData = { 
                targetColor: 'correct', 
                name: '林静怡', 
                colorName: '绿色',
                targetRow: 0,
                houseName: '林静怡手机GPS定位',
                isJumping: true,
                baseY: 1
            };
            greenChar.position.set(startX - 3, 1, startZ + 0 * spacingZ);
            scene.add(greenChar);
            characters.push(greenChar);

            // Green house at Row 1
            houses['green'] = createHouse(startX + 5 * spacingX + 2, startZ + 0 * spacingZ, 0x22c55e, 'green', '第1行');

            // Gray character - Row 2 (index 1)
            const grayChar = createCharacter(0x6b7280, 'gray');
            grayChar.userData = { 
                targetColor: 'absent', 
                name: '???', 
                colorName: '灰色',
                targetRow: 1,
                houseName: '???设备GPS定位',
                isJumping: true,
                baseY: 1
            };
            grayChar.position.set(startX - 3, 1, startZ + 1 * spacingZ);
            scene.add(grayChar);
            characters.push(grayChar);

            // Gray house at Row 2
            houses['gray'] = createHouse(startX + 5 * spacingX + 2, startZ + 1 * spacingZ, 0x6b7280, 'gray', '第2行');

            // Yellow character - Row 4 (index 3)
            const yellowChar = createCharacter(0xeab308, 'yellow');
            yellowChar.userData = { 
                targetColor: 'present', 
                name: '周变', 
                colorName: '黄色',
                targetRow: 3,
                houseName: '周变相关GPS定位',
                isJumping: true,
                baseY: 1
            };
            yellowChar.position.set(startX - 3, 1, startZ + 3 * spacingZ);
            scene.add(yellowChar);
            characters.push(yellowChar);

            // Yellow house at Row 4
            houses['yellow'] = createHouse(startX + 5 * spacingX + 2, startZ + 3 * spacingZ, 0xeab308, 'yellow', '第4行');

            // Ground - 改为米色，无网格线
            const groundGeo = new THREE.PlaneGeometry(40, 35);
            const groundMat = new THREE.MeshLambertMaterial({ color: 0xf1efe8 }); // 与背景一致的米色
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -0.5;
            ground.receiveShadow = true;
            scene.add(ground);

            // 不再添加GridHelper，去除网格线

            // 注释掉原来的小人动画触发，改为由相机动画完成后触发
            // setTimeout(() => animateAllCharacters(), 1000);
            
            // 启动相机动画（延迟一点开始，让场景先加载完成）
            setTimeout(() => {
                startCameraAnimation();
            }, 1000);
            
            window.addEventListener('resize', onWindowResize, false);
            animate();
        }

        // 创建3D格子（有输入的行）
        function createBlock(col, row, letter, x, z, colorHex, colorType) {
            const geometry = new THREE.BoxGeometry(1.8, 1, 1.8);
            const material = new THREE.MeshLambertMaterial({ color: colorHex });
            const block = new THREE.Mesh(geometry, material);

            block.position.set(x, 0.5, z);
            block.castShadow = true;
            block.receiveShadow = true;
            block.userData = { color: colorType, col: col, row: row, letter: letter, is3D: true };

            // Letter
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#' + colorHex.toString(16).padStart(6, '0');
            ctx.fillRect(0, 0, 128, 128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 80px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(letter, 64, 64);

            const texture = new THREE.CanvasTexture(canvas);
            const letterMesh = new THREE.Mesh(
                new THREE.PlaneGeometry(1.6, 1.6),
                new THREE.MeshBasicMaterial({ map: texture })
            );
            letterMesh.rotation.x = -Math.PI / 2;
            letterMesh.position.y = 0.51;
            block.add(letterMesh);

            scene.add(block);
            allBlocks.push(block);
            return block;
        }

        // 创建2D方形图案（没有输入的行）
        function createEmptyPattern(col, row, x, z) {
            const group = new THREE.Group();
            
            // 外框（稍大一点的深色边框）
            const borderGeo = new THREE.PlaneGeometry(2.0, 2.0);
            const borderMat = new THREE.MeshBasicMaterial({ 
                color: 0x3d3d3d,
                side: THREE.DoubleSide
            });
            const border = new THREE.Mesh(borderGeo, borderMat);
            border.rotation.x = -Math.PI / 2;
            border.position.y = 0.02;
            group.add(border);
            
            // 内部（稍小一点的背景色）- 用更浅的米色
            const innerGeo = new THREE.PlaneGeometry(1.8, 1.8);
            const innerMat = new THREE.MeshBasicMaterial({ 
                color: 0xf1efe8, // 与背景一致
                side: THREE.DoubleSide
            });
            const inner = new THREE.Mesh(innerGeo, innerMat);
            inner.rotation.x = -Math.PI / 2;
            inner.position.y = 0.03;
            group.add(inner);
            
            // 添加淡淡的网格线效果
            const lineGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(1.8, 0, 1.8));
            const lineMat = new THREE.LineBasicMaterial({ color: 0x4a4a4a, linewidth: 2 });
            const lines = new THREE.LineSegments(lineGeo, lineMat);
            lines.position.y = 0.04;
            group.add(lines);

            group.position.set(x, 0, z);
            group.userData = { col: col, row: row, isEmptyPattern: true };
            
            scene.add(group);
            allBlocks.push(group);
            return group;
        }

        function createCharacter(color, type) {
            const group = new THREE.Group();

            const bodyGeo = new THREE.CylinderGeometry(0.3, 0.4, 0.8, 8);
            const bodyMat = new THREE.MeshLambertMaterial({ color: color });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.4;
            body.castShadow = true;
            group.add(body);

            const headGeo = new THREE.SphereGeometry(0.35, 16, 16);
            const head = new THREE.Mesh(headGeo, bodyMat);
            head.position.y = 1.1;
            head.castShadow = true;
            group.add(head);

            // Eyes
            const eyeGeo = new THREE.SphereGeometry(0.08, 8, 8);
            const eyeMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat);
            leftEye.position.set(-0.12, 1.15, 0.25);
            group.add(leftEye);

            const rightEye = new THREE.Mesh(eyeGeo, eyeMat);
            rightEye.position.set(0.12, 1.15, 0.25);
            group.add(rightEye);

            const pupilGeo = new THREE.SphereGeometry(0.04, 8, 8);
            const pupilMat = new THREE.MeshBasicMaterial({ color: 0x000000 });
            const leftPupil = new THREE.Mesh(pupilGeo, pupilMat);
            leftPupil.position.set(-0.12, 1.15, 0.32);
            group.add(leftPupil);

            const rightPupil = new THREE.Mesh(pupilGeo, pupilMat);
            rightPupil.position.set(0.12, 1.15, 0.32);
            group.add(rightPupil);

            return group;
        }

        function createHouse(x, z, color, type, rowLabel) {
            const house = new THREE.Group();

            // House body - 使用木质色
            const houseBodyGeo = new THREE.BoxGeometry(2.2, 2.2, 2.2);
            const houseBodyMat = new THREE.MeshLambertMaterial({ color: 0x8b7355 });
            const houseBody = new THREE.Mesh(houseBodyGeo, houseBodyMat);
            houseBody.position.y = 1.1;
            houseBody.castShadow = true;
            house.add(houseBody);

            // Roof - 使用对应颜色
            const roofGeo = new THREE.ConeGeometry(1.6, 1.5, 4);
            const roofMat = new THREE.MeshLambertMaterial({ color: color });
            const roof = new THREE.Mesh(roofGeo, roofMat);
            roof.position.y = 3;
            roof.rotation.y = Math.PI / 4;
            roof.castShadow = true;
            house.add(roof);

            // Door
            const doorGeo = new THREE.BoxGeometry(0.7, 1.2, 0.1);
            const doorMat = new THREE.MeshLambertMaterial({ color: 0x2d3748 });
            const door = new THREE.Mesh(doorGeo, doorMat);
            door.position.set(0, 0.6, 1.15);
            house.add(door);

            // Row label on house
            const canvas = document.createElement('canvas');
            canvas.width = 256;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#8b7355';
            ctx.fillRect(0, 0, 256, 128);
            ctx.fillStyle = 'white';
            ctx.font = 'bold 40px "Courier New", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(rowLabel, 128, 64);

            const labelTexture = new THREE.CanvasTexture(canvas);
            const labelGeo = new THREE.PlaneGeometry(1.8, 0.9);
            const labelMat = new THREE.MeshBasicMaterial({ map: labelTexture, transparent: true });
            const labelMesh = new THREE.Mesh(labelGeo, labelMat);
            labelMesh.position.set(0, 1.8, 1.12);
            house.add(labelMesh);

            house.position.set(x, 0, z);
            scene.add(house);

            return { mesh: house, position: new THREE.Vector3(x, 0, z) };
        }

        // 持续跳动动画
        function startContinuousJumping() {
            characters.forEach(char => {
                startCharacterJump(char);
            });
        }

        function startCharacterJump(character) {
            let jumpTime = 0;
            const jumpSpeed = 0.08;
            const jumpHeight = 0.3;
            
            function jump() {
                if (!character.userData.isJumping) return;
                
                jumpTime += jumpSpeed;
                character.position.y = character.userData.baseY + Math.abs(Math.sin(jumpTime)) * jumpHeight;
                
                // 添加轻微的旋转
                character.rotation.y = Math.sin(jumpTime * 0.5) * 0.1;
                
                requestAnimationFrame(jump);
            }
            jump();
        }

        function animateAllCharacters() {
            let completed = 0;
            const results = [];

            characters.forEach((char, index) => {
                setTimeout(() => {
                    // 检查该行是否有输入
                    const rowHasInput = allGuesses.some(g => g.row === char.userData.targetRow);
                    
                    if (!rowHasInput) {
                        // 该行没有输入，直接判定为无法前进
                        updateStatus(`${char.userData.name}：❌ 第${char.userData.targetRow + 1}行没有输入，无法前进！`, 'error');
                        results.push({ 
                            name: char.userData.name, 
                            success: false, 
                            message: `第${char.userData.targetRow + 1}行没有输入`, 
                            pathLength: 0,
                            houseName: char.userData.houseName
                        });
                        completed++;
                        if (completed === 3) showFinalResults(results);
                        return;
                    }

                    // 检查该行第一个格子颜色是否匹配
                    const firstBlock = allBlocks.find(b => b.userData.row === char.userData.targetRow && b.userData.col === 0 && b.userData.is3D);
                    if (!firstBlock || firstBlock.userData.color !== char.userData.targetColor) {
                        const actualColor = firstBlock ? firstBlock.userData.color : '无';
                        updateStatus(`${char.userData.name}：❌ 第${char.userData.targetRow + 1}行第1格是${actualColor}色，不是${char.userData.colorName}，无法前进！`, 'error');
                        results.push({ 
                            name: char.userData.name, 
                            success: false, 
                            message: `第1格颜色不匹配(${actualColor})`, 
                            pathLength: 0,
                            houseName: char.userData.houseName
                        });
                        completed++;
                        if (completed === 3) showFinalResults(results);
                        return;
                    }

                    // 条件满足，开始寻路（使用新的寻路算法）
                    findAndAnimatePathNew(char, (success, message, pathLength) => {
                        results.push({ 
                            name: char.userData.name, 
                            success, 
                            message, 
                            pathLength,
                            houseName: char.userData.houseName
                        });
                        completed++;
                        if (completed === 3) showFinalResults(results);
                    });
                }, index * 800);
            });
        }

        // 新的寻路算法：优先前方，其次上下，最终到达正确终点
        function findAndAnimatePathNew(character, callback) {
            const targetColor = character.userData.targetColor;
            const name = character.userData.name;
            const colorName = character.userData.colorName;
            const targetRow = character.userData.targetRow;
            const houseName = character.userData.houseName;

            // 暂时停止持续跳动
            character.userData.isJumping = false;

            // 使用新的寻路算法找到路径
            const path = findPathWithNewAlgorithm(character.position, targetColor, targetRow);

            if (!path || path.length === 0) {
                updateStatus(`${name}：找不到通往${houseName}的路径！`, 'error');
                // 恢复跳动
                character.userData.isJumping = true;
                startCharacterJump(character);
                callback(false, `无法到达${houseName}`, 0);
                return;
            }

            // 检查路径终点是否到达目标（第4列或更右，且行号正确）
            const lastBlock = path[path.length - 1];
            const reachedTarget = lastBlock.userData.col >= 4 && lastBlock.userData.row === targetRow;

            if (!reachedTarget) {
                updateStatus(`${name}：❌ 路径无法到达${houseName}（终点在第${lastBlock.userData.row + 1}行第${lastBlock.userData.col + 1}格）`, 'error');
                // 恢复跳动
                character.userData.isJumping = true;
                startCharacterJump(character);
                callback(false, `路径未到达目标`, path.length);
                return;
            }

            // Animate along path
            let step = 0;

            function moveStep() {
                if (step >= path.length) {
                    // Move to house
                    moveToHouse(character, targetColor, () => {
                        const moves = path.map((b, i) => {
                            if (i === 0) return `起点(${b.userData.row+1},${b.userData.col+1})`;
                            const prev = path[i-1];
                            let dir = '';
                            if (b.userData.row === prev.userData.row) dir = '右';
                            else if (b.userData.row > prev.userData.row) dir = '下';
                            else dir = '上';
                            return `${dir}(${b.userData.row+1},${b.userData.col+1})`;
                        }).join(' → ');

                        updateStatus(`${name}：✅ 成功到达${houseName}！路径：${moves}`, 'success');
                        callback(true, `成功到达${houseName}，共${path.length}步`, path.length);
                    });
                    return;
                }

                const target = path[step];
                highlightBlock(target);

                const startPos = character.position.clone();
                const endPos = new THREE.Vector3(target.position.x, 1.5, target.position.z);

                let progress = 0;
                function animateJump() {
                    progress += 0.08;
                    if (progress <= 1) {
                        character.position.lerpVectors(startPos, endPos, progress);
                        character.position.y = 1.5 + Math.sin(progress * Math.PI) * 0.6;
                        character.lookAt(endPos.x, character.position.y, endPos.z);
                        requestAnimationFrame(animateJump);
                    } else {
                        character.position.copy(endPos);
                        character.position.y = 1;
                        character.userData.baseY = 1;
                        step++;
                        setTimeout(moveStep, 120);
                    }
                }
                animateJump();
            }

            const startBlock = path[0];
            updateStatus(`${name}：从(${startBlock.userData.row+1},${startBlock.userData.col+1})出发，目标${houseName}...`, 'info');
            moveStep();
        }

        // 新的寻路算法：优先前方，其次上下
        function findPathWithNewAlgorithm(startPos, targetColor, targetRow) {
            // 获取所有该颜色的3D格子
            const colorBlocks = allBlocks.filter(b => b.userData.color === targetColor && b.userData.is3D);
            if (colorBlocks.length === 0) return null;

            // 找到起始格子（目标行第0列）
            const startBlock = allBlocks.find(b => b.userData.row === targetRow && b.userData.col === 0 && b.userData.is3D);
            if (!startBlock) return null;

            // 使用BFS寻找路径，但优先级为：右 > 上/下
            const path = [];
            const visited = new Set();
            let current = startBlock;

            path.push(current);
            visited.add(`${current.userData.row}-${current.userData.col}`);

            // 最大步数限制，防止无限循环
            let maxSteps = 20;
            let steps = 0;

            while (steps < maxSteps) {
                const next = findNextBlockWithPriority(current, targetColor, visited, targetRow);
                if (!next) break;

                path.push(next);
                visited.add(`${next.userData.row}-${next.userData.col}`);
                current = next;
                steps++;

                // 检查是否到达目标（第4列且行号正确）
                if (current.userData.col >= 4 && current.userData.row === targetRow) {
                    break;
                }
            }

            // 检查是否成功到达目标
            const lastBlock = path[path.length - 1];
            if (lastBlock.userData.col < 4 || lastBlock.userData.row !== targetRow) {
                // 未到达目标，返回部分路径
                return path;
            }

            return path;
        }

        // 根据优先级寻找下一个格子：右 > 上/下
        function findNextBlockWithPriority(current, targetColor, visited, targetRow) {
            const row = current.userData.row;
            const col = current.userData.col;

            // 定义方向优先级：右(0,1) > 上(-1,0) > 下(1,0)
            // 注意：上/下选择取决于哪个方向更接近目标行
            const directions = [];

            // 1. 优先：右边
            directions.push({ r: 0, c: 1, priority: 3 });

            // 2. 其次：上下方向（根据目标行决定优先级）
            if (row > targetRow) {
                // 当前在目标行下方，优先向上
                directions.push({ r: -1, c: 0, priority: 2 });
                directions.push({ r: 1, c: 0, priority: 1 });
            } else if (row < targetRow) {
                // 当前在目标行上方，优先向下
                directions.push({ r: 1, c: 0, priority: 2 });
                directions.push({ r: -1, c: 0, priority: 1 });
            } else {
                // 当前就在目标行，上下优先级相同（但通常不需要上下移动）
                directions.push({ r: -1, c: 0, priority: 2 });
                directions.push({ r: 1, c: 0, priority: 2 });
            }

            // 按优先级排序
            directions.sort((a, b) => b.priority - a.priority);

            // 尝试每个方向
            for (let dir of directions) {
                const newRow = row + dir.r;
                const newCol = col + dir.c;
                const key = `${newRow}-${newCol}`;

                // 检查边界和访问状态
                if (visited.has(key)) continue;
                if (newRow < 0 || newRow >= 6 || newCol < 0 || newCol >= 5) continue;

                // 查找该位置的同颜色3D格子
                const block = allBlocks.find(b => 
                    b.userData.row === newRow && 
                    b.userData.col === newCol && 
                    b.userData.color === targetColor &&
                    b.userData.is3D
                );

                if (block) return block;
            }

            return null;
        }

        function moveToHouse(character, targetColor, callback) {
            const house = houses[targetColor === 'correct' ? 'green' : targetColor === 'present' ? 'yellow' : 'gray'];
            if (!house) { 
                character.userData.isJumping = true;
                startCharacterJump(character);
                callback(); 
                return; 
            }

            const housePos = house.position.clone();
            housePos.x -= 2; // Stop before house
            housePos.y = 1;

            const startPos = character.position.clone();
            let progress = 0;

            function stepAnimation() {
                progress += 0.04;
                if (progress <= 1) {
                    character.position.lerpVectors(startPos, housePos, progress);
                    character.position.y = 1 + Math.sin(progress * Math.PI) * 0.8;
                    requestAnimationFrame(stepAnimation);
                } else {
                    character.position.copy(housePos);
                    character.userData.baseY = 1;
                    celebrate(character);
                    // 到达房子后继续跳动
                    setTimeout(() => {
                        character.userData.isJumping = true;
                        startCharacterJump(character);
                    }, 1000);
                    callback();
                }
            }
            stepAnimation();
        }

        function highlightBlock(block) {
            // 只对3D格子进行高亮
            if (block.userData.is3D) {
                const originalScale = block.scale.clone();
                block.scale.set(1.15, 1.15, 1.15);
                setTimeout(() => block.scale.copy(originalScale), 250);
            }
        }

        function celebrate(character) {
            let count = 0;
            const startY = character.position.y;

            function jump() {
                if (count > 4) { 
                    character.position.y = startY; 
                    return; 
                }
                let p = 0;
                function step() {
                    p += 0.15;
                    if (p <= Math.PI) {
                        character.position.y = startY + Math.sin(p) * 0.6;
                        requestAnimationFrame(step);
                    } else {
                        character.position.y = startY;
                        count++;
                        setTimeout(jump, 60);
                    }
                }
                step();
            }
            jump();
        }

        function updateStatus(message, type) {
            const desc = document.getElementById('scene-desc');
            const colors = { success: '#4ade80', error: '#f87171', info: '#60a5fa', warning: '#fbbf24' };
            const icons = { success: '✅', error: '❌', info: 'ℹ️', warning: '⚠️' };

            const div = document.createElement('div');
            div.style.color = colors[type] || '#000';
            div.style.marginBottom = '3px';
            div.style.fontSize = '11px';
            div.innerHTML = `${icons[type] || '•'} ${message}`;
            desc.appendChild(div);
            desc.scrollTop = desc.scrollHeight;
        }

        function showFinalResults(results) {
            const desc = document.getElementById('scene-desc');
            const successCount = results.filter(r => r.success).length;

            let html = '<div style="border-top: 1px solid rgba(0,0,0,0.2); margin-top: 8px; padding-top: 8px;">';
            html += `<div style="font-size: 14px; font-weight: bold; color: ${successCount === 3 ? '#4ade80' : successCount > 0 ? '#fbbf24' : '#f87171'}; margin-bottom: 6px;">🏆 最终结果：${successCount}/3 到达目标房屋</div>`;

            results.forEach(r => {
                const icon = r.success ? '✅' : '❌';
                const color = r.success ? '#4ade80' : '#f87171';
                html += `<div style="color: ${color}; font-size: 10px; margin: 2px 0;">${icon} <strong>${r.name}</strong> → ${r.houseName}：${r.message}</div>`;
            });

            html += '</div>';
            desc.innerHTML += html;
            desc.scrollTop = desc.scrollHeight;

            // 只有当三个小人都成功（successCount === 3）时，才跳转到 GPS3.html
            if (successCount === 3) {
                setTimeout(() => {
                    window.location.href = 'GPS3.html';
                }, 3000); // 延迟3秒以便用户查看结果，然后跳转
            }
            // 否则，不执行任何跳转，停留在当前页面
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = 16;
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // 更新相机动画
            updateCameraAnimation();
            
            renderer.render(scene, camera);
        }

        function resetGame() { 
            charactersAnimationStarted = false; // 重置标志位
            location.reload(); 
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleKey('ENTER');
            else if (e.key === 'Backspace') handleKey('BACKSPACE');
            else if (e.key.length === 1 && e.key.match(/[a-zA-Z]/)) handleKey(e.key.toUpperCase());
        });

        // 初始化
        initGrid();
        initKeyboard();
        updateKeyboardForRow(0); // 初始化键盘状态
    </script>
</body>
</html>
